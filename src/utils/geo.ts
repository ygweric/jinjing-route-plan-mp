import { Location } from 'types';

/**
 * 判断单个marker是否在region中
 * @param markerGeo
 * @param northeast maxGeo
 * @param southwest  minGeo
 */
export const isMarkerInRegion = (
  markerGeo: Location,
  northeast: Location,
  southwest: Location
) => {
  const { longitude: left, latitude: top } = northeast;
  const { longitude: right, latitude: bottom } = southwest;

  return (
    markerGeo.longitude < left &&
    markerGeo.longitude > right &&
    markerGeo.latitude < top &&
    markerGeo.latitude > bottom
  );
};


// ---------------------------------
type Point = { longitude: number; latitude: number };

/**
 * 扩展线条为某个宽度的带状
 * Generated by 通义千问
 * @param points 
 * @param width 
 * @returns 
 */
export function expandLineWithWidth(points: Point[], width: number): Point[] {
    if (points.length < 2) {
        throw new Error('至少需要两个点来定义一条线');
    }

    // 计算向量方向并外扩得到新点
    function getExpandedPoints(point1: Point, point2: Point, widthHalf: number): Point[] {
        const dx = point2.longitude - point1.longitude;
        const dy = point2.latitude - point1.latitude;
        const length = Math.sqrt(dx ** 2 + dy ** 2);
        const angle = Math.atan2(dy, dx); // 获取当前线段的角度
        // 外扩向量
        const offsetVector1 = { longitude: point1.longitude + widthHalf * Math.cos(angle - Math.PI / 2), latitude: point1.latitude + widthHalf * Math.sin(angle - Math.PI / 2) };
        const offsetVector2 = { longitude: point2.longitude + widthHalf * Math.cos(angle - Math.PI / 2), latitude: point2.latitude + widthHalf * Math.sin(angle - Math.PI / 2) };
        return [offsetVector1, offsetVector2];
    }

    const halfWidth = width / 2;
    let polygonPoints: Point[] = [points[0]];

    for (let i = 1; i < points.length; i++) {
        const expandedPair = getExpandedPoints(points[i - 1], points[i], halfWidth);
        polygonPoints.push(...expandedPair);
    }

    // 闭合多边形，回到起点
    const firstPair = getExpandedPoints(points[points.length - 1], points[0], halfWidth);
    polygonPoints.push(firstPair[0]); // 注意，这里我们只添加了第一个外扩点以闭合多边形，避免重复添加最后一个点

    return polygonPoints;
}
